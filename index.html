<!-- Parte 1/2 -->
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto Paper Trader (Binance) — Autónomo</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1830; --line:rgba(169,183,229,.16);
      --text:#dbe6ff; --muted:#a9b7e5; --good:#19d3a2; --bad:#ff5c7a; --warn:#ffcc66;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:var(--sans);background:var(--bg);color:var(--text)}
    header{padding:14px 16px;border-bottom:1px solid var(--line);background:rgba(0,0,0,.25)}
    h1{margin:0;font-size:16px}
    .sub{color:var(--muted);font-size:12px;margin-top:4px;line-height:1.2}
    .wrap{padding:14px 16px;display:grid;grid-template-columns:340px 1fr;gap:12px}
    @media(max-width:980px){.wrap{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line); border-radius:16px; overflow:hidden}
    .hd{padding:10px 12px;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;gap:8px;align-items:center}
    .bd{padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{cursor:pointer;border:1px solid rgba(169,183,229,.25);background:rgba(255,255,255,.05);color:var(--text);
      padding:10px 12px;border-radius:12px;font-weight:700}
    .btn.primary{border-color:rgba(25,211,162,.45);background:rgba(25,211,162,.12)}
    .btn.danger{border-color:rgba(255,92,122,.45);background:rgba(255,92,122,.12)}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    label{display:flex;flex-direction:column;gap:6px;font-size:12px;color:var(--muted)}
    input,select{width:100%;padding:10px 10px;border-radius:12px;border:1px solid rgba(169,183,229,.22);
      background:rgba(9,14,30,.65);color:var(--text);outline:none}
    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
    @media(max-width:980px){.kpis{grid-template-columns:repeat(2,1fr)}}
    .kpi{border:1px solid rgba(169,183,229,.18);background:rgba(0,0,0,.18);border-radius:14px;padding:10px 12px}
    .kpi .k{font-size:11px;color:var(--muted)}
    .kpi .v{font-size:16px;font-weight:900;margin-top:4px;font-family:var(--mono)}
    .good{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    .mono{font-family:var(--mono)}
    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .log{width:100%;min-height:240px;resize:vertical;font-family:var(--mono);font-size:11px;
      padding:10px;border-radius:12px;border:1px solid rgba(169,183,229,.22);background:rgba(0,0,0,.25);color:var(--text)}
    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{padding:9px 8px;border-bottom:1px solid rgba(169,183,229,.14);text-align:left;vertical-align:top}
    th{font-size:11px;color:var(--muted)}
    .tag{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(169,183,229,.22);background:rgba(255,255,255,.03);font-size:11px}
    .bar{height:10px;border-radius:999px;border:1px solid rgba(169,183,229,.20);background:rgba(0,0,0,.25);overflow:hidden}
    .bar > i{display:block;height:100%;width:0%;background:linear-gradient(90deg, rgba(25,211,162,.85), rgba(70,120,255,.85))}
  </style>
</head>

<body>
<header>
  <h1>Auto Paper Trader (Binance) — Autónomo TOP50 + MultiTF</h1>
  <div class="sub">Optimiza solo (fases) → elige TOP3 → paper trading con fills realistas. Binance fallback incluido. Firebase opcional (no rompe si falla).</div>
</header>

<div class="wrap">
  <section class="card">
    <div class="hd">
      <div><b>Control</b></div>
      <div class="mono small" id="uidPill">uid: —</div>
    </div>
    <div class="bd">
      <div class="row">
        <button class="btn primary" id="btnStart">Iniciar</button>
        <button class="btn danger" id="btnStop" disabled>Detener</button>
        <button class="btn" id="btnNotify">Notificaciones</button>
      </div>

      <div style="height:10px"></div>

      <div class="row" style="width:100%">
        <label style="flex:1">Capital inicial (USD)
          <input id="startBal" type="number" step="0.01" value="20" />
        </label>
        <label style="flex:1">Polling (seg)
          <input id="pollSec" type="number" step="1" value="60" />
        </label>
      </div>

      <div class="row" style="width:100%">
        <label style="flex:1">TOP N (auto)
          <select id="topN">
            <option value="30">30</option>
            <option value="50" selected>50</option>
          </select>
        </label>
        <label style="flex:1">Velas por backtest
          <input id="btLimit" type="number" step="50" value="700" />
        </label>
      </div>

      <div class="row" style="width:100%">
        <label style="flex:1">Filtro: mín trades
          <input id="minTrades" type="number" step="1" value="40" />
        </label>
        <label style="flex:1">Filtro: máx DD (%)
          <input id="maxDD" type="number" step="1" value="35" />
        </label>
      </div>

      <div class="row" style="width:100%">
        <label style="flex:1">Optimización por fases
          <select id="optMode">
            <option value="fast" selected>FAST (recomendado)</option>
            <option value="full">FULL (más lento)</option>
          </select>
        </label>
        <label style="flex:1">Reopt diaria
          <select id="reoptDaily">
            <option value="yes" selected>Sí</option>
            <option value="no">No</option>
          </select>
        </label>
      </div>

      <div style="height:10px"></div>

      <div class="small"><b>Progreso</b>: <span class="mono" id="progText">—</span></div>
      <div class="bar" aria-label="progress"><i id="progBar"></i></div>

      <div style="height:12px"></div>

      <div class="small"><b>Estado</b>: <span id="status" class="warn">idle</span></div>
      <div class="small"><b>Etapa</b>: <span id="stage" class="mono">—</span></div>
      <div class="small"><b>Debug</b>: abre consola si quieres, pero aquí también verás errores.</div>

      <div style="height:12px"></div>
      <textarea id="log" class="log" spellcheck="false"></textarea>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div><b>Dashboard</b></div>
      <div class="mono small" id="netPill">binance: —</div>
    </div>
    <div class="bd">
      <div class="kpis">
        <div class="kpi"><div class="k">Start</div><div class="v">$<span id="kStart">—</span></div></div>
        <div class="kpi"><div class="k">Balance</div><div class="v">$<span id="kBal">—</span></div></div>
        <div class="kpi"><div class="k">Retorno</div><div class="v" id="kRet">—</div></div>
        <div class="kpi"><div class="k">Trades</div><div class="v"><span id="kTrades">—</span></div></div>
      </div>

      <div style="height:12px"></div>

      <div class="card" style="border-radius:14px">
        <div class="hd">
          <div><b>TOP3 actual</b></div>
          <div class="mono small" id="optInfo">—</div>
        </div>
        <div class="bd">
          <div id="topList" class="small">—</div>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="card" style="border-radius:14px">
        <div class="hd"><div><b>Trades recientes</b></div><div class="small mono">paper</div></div>
        <div class="bd" style="padding:0;max-height:360px;overflow:auto">
          <table>
            <thead>
              <tr>
                <th>Fecha</th><th>Símbolo</th><th>TF</th><th>Strat</th><th>Side</th><th>PnL</th><th>Motivo</th>
              </tr>
            </thead>
            <tbody id="tradesTbody"></tbody>
          </table>
        </div>
      </div>

      <div style="height:12px"></div>
      <div class="small">
        <b>Nota:</b> si ves “Failed to fetch”, esta versión prueba varios hosts de Binance automáticamente.
      </div>
    </div>
  </section>
</div>

<script type="module">
  // =========================
  // Firebase OPTIONAL + SAFE
  // =========================
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
  import { getFirestore, doc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDIW25TJo-ifjKVl45OdEpz7GEtopyiE7k",
    authDomain: "realty-wealth-3b43a.firebaseapp.com",
    projectId: "realty-wealth-3b43a",
    storageBucket: "realty-wealth-3b43a.firebasestorage.app",
    messagingSenderId: "1003886283442",
    appId: "1:1003886283442:web:e2faceab70b1451e4997ab",
    measurementId: "G-TDPC663GRE"
  };

  let FB = { ok:false, uid:null, auth:null, db:null };
  try{
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    onAuthStateChanged(auth, async (user)=>{
      if(user){
        FB.ok=true; FB.uid=user.uid; FB.auth=auth; FB.db=db;
        document.getElementById("uidPill").textContent = "uid: "+user.uid.slice(0,8)+"…";
        try{
          await setDoc(doc(db,"users",user.uid), { createdAt: serverTimestamp() }, { merge:true });
        }catch{}
      }else{
        signInAnonymously(auth).catch(()=>{});
      }
    });
  }catch(e){
    // Firebase no debe romper la app
    console.warn("Firebase no disponible:", e);
  }
  window.__FB = FB;
</script>

<script>
/* =========================================================
   APP CORE (autónoma)
========================================================= */
const $ = (id)=>document.getElementById(id);
const fmt = (n,d=2)=> Number.isFinite(n)? n.toFixed(d):"—";
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
const clamp = (x,a,b)=> Math.max(a, Math.min(b,x));
const now = ()=> Date.now();

function setStatus(txt, cls="warn"){
  $("status").textContent = txt;
  $("status").className = cls;
}
function setStage(txt){ $("stage").textContent = txt; }
function log(msg){
  const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
  $("log").value = line + "\n" + $("log").value;
}
function setProg(done,total,extra=""){
  const pct = total? Math.round((done/total)*100):0;
  $("progText").textContent = `${done}/${total} (${pct}%) ${extra}`;
  $("progBar").style.width = `${pct}%`;
}

/* =========================
   NOTIFICATIONS
========================= */
async function askNotifications(){
  if(!("Notification" in window)){ log("Notificaciones: no soportado."); return; }
  const p = await Notification.requestPermission();
  log("Notificaciones permiso: "+p);
}
function notify(title, body){
  if(!("Notification" in window)) return;
  if(Notification.permission!=="granted") return;
  try{ new Notification(title,{body}); }catch{}
}

/* =========================
   BINANCE FALLBACK
========================= */
const BINANCE_BASES = [
  "https://api.binance.com",
  "https://data-api.binance.vision",
  "https://api1.binance.com",
  "https://api2.binance.com",
  "https://api3.binance.com"
];

async function retryFetchJson(url, tries=4){
  let wait = 350;
  for(let i=0;i<tries;i++){
    try{
      const res = await fetch(url);
      if(res.ok) return await res.json();
      if(res.status===429 || res.status===418 || res.status===503){
        await sleep(wait); wait=Math.min(5000, Math.floor(wait*1.6)); continue;
      }
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status} ${txt?.slice(0,120)}`);
    }catch(e){
      if(i===tries-1) throw e;
      await sleep(wait); wait=Math.min(5000, Math.floor(wait*1.6));
    }
  }
  throw new Error("retryFetchJson: failed");
}

async function binanceFetch(path){
  let last=null;
  for(const base of BINANCE_BASES){
    try{
      const data = await retryFetchJson(base+path, 3);
      $("netPill").textContent = "binance: "+base.replace("https://","");
      return data;
    }catch(e){
      last=e;
      log(`Binance base falló: ${base} (${e.message||e})`);
      await sleep(120);
    }
  }
  throw last || new Error("Binance unreachable");
}

async function fetchExchangeInfo(){
  return binanceFetch("/api/v3/exchangeInfo");
}
async function fetch24hTickers(){
  return binanceFetch("/api/v3/ticker/24hr");
}
async function fetchKlines(symbol, interval, limit){
  const p = `/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
  const d = await binanceFetch(p);
  return d.map(k=>({ t:+k[0], o:+k[1], h:+k[2], l:+k[3], c:+k[4] }));
}
async function fetchBookTicker(symbol){
  const p = `/api/v3/ticker/bookTicker?symbol=${encodeURIComponent(symbol)}`;
  const d = await binanceFetch(p);
  return { bid:+d.bidPrice, ask:+d.askPrice };
}

/* =========================
   AUTO UNIVERSE
========================= */
const EXCLUDE = new Set(["USDCUSDT","FDUSDUSDT","TUSDUSDT","USDPUSDT","BUSDUSDT","DAIUSDT","PYUSDUSDT"]);
const ALL_TFS = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"];

function isExcluded(sym){
  if(EXCLUDE.has(sym)) return true;
  if(sym.endsWith("UPUSDT")||sym.endsWith("DOWNUSDT")) return true;
  if(sym.includes("BULLUSDT")||sym.includes("BEARUSDT")) return true;
  return false;
}

async function discoverTopSymbols(topN=50){
  setStage("Descubriendo TOP símbolos (exchangeInfo + 24h)...");
  const [ex, t24] = await Promise.all([fetchExchangeInfo(), fetch24hTickers()]);
  const spotUSDT = new Set(
    ex.symbols
      .filter(s=>s.status==="TRADING" && s.quoteAsset==="USDT" && s.isSpotTradingAllowed!==false)
      .map(s=>s.symbol)
      .filter(s=>!isExcluded(s))
  );
  const ranked = t24
    .filter(t=>spotUSDT.has(t.symbol))
    .map(t=>({symbol:t.symbol, qv:Number(t.quoteVolume)||0}))
    .sort((a,b)=>b.qv-a.qv);
  return ranked.slice(0, topN).map(x=>x.symbol);
}

/* =========================
   INDICATORS
========================= */
function sma(arr,p){
  const out=new Array(arr.length).fill(null);
  let sum=0;
  for(let i=0;i<arr.length;i++){
    sum+=arr[i];
    if(i>=p) sum-=arr[i-p];
    if(i>=p-1) out[i]=sum/p;
  }
  return out;
}
function ema(arr,p){
  const out=new Array(arr.length).fill(null);
  const k=2/(p+1);
  let prev=null;
  for(let i=0;i<arr.length;i++){
    const v=arr[i];
    if(prev===null){
      if(i>=p-1){
        prev=arr.slice(i-p+1,i+1).reduce((a,b)=>a+b,0)/p;
        out[i]=prev;
      }
    }else{
      prev=v*k+prev*(1-k);
      out[i]=prev;
    }
  }
  return out;
}
function rsi(closes,p=14){
  const out=new Array(closes.length).fill(null);
  let avgG=null, avgL=null;
  for(let i=1;i<closes.length;i++){
    const ch=closes[i]-closes[i-1];
    const g=Math.max(ch,0), l=Math.max(-ch,0);
    if(i<p){ avgG=(avgG??0)+g; avgL=(avgL??0)+l; continue; }
    if(i===p){ avgG=((avgG??0)+g)/p; avgL=((avgL??0)+l)/p; }
    else{ avgG=(avgG*(p-1)+g)/p; avgL=(avgL*(p-1)+l)/p; }
    const rs=(avgL===0)?999:(avgG/avgL);
    out[i]=100-(100/(1+rs));
  }
  return out;
}
function macd(closes, fast=12, slow=26, sig=9){
  const ef=ema(closes,fast), es=ema(closes,slow);
  const line=closes.map((_,i)=> (ef[i]==null||es[i]==null)?null:(ef[i]-es[i]));
  const filled=line.map(v=>v==null?0:v);
  const signal=ema(filled,sig).map((v,i)=> line[i]==null?null:v);
  const hist=line.map((v,i)=> (v==null||signal[i]==null)?null:(v-signal[i]));
  return {line,signal,hist};
}
function bollinger(closes,p=20,m=2){
  const mid=sma(closes,p);
  const up=new Array(closes.length).fill(null);
  const lo=new Array(closes.length).fill(null);
  for(let i=0;i<closes.length;i++){
    if(i<p-1) continue;
    const slice=closes.slice(i-p+1,i+1);
    const mu=mid[i];
    const varc=slice.reduce((a,v)=>a+(v-mu)*(v-mu),0)/p;
    const sd=Math.sqrt(varc);
    up[i]=mu+m*sd; lo[i]=mu-m*sd;
  }
  return {mid,upper:up,lower:lo};
}
function donchian(candles,p=20){
  const hi=new Array(candles.length).fill(null);
  const lo=new Array(candles.length).fill(null);
  for(let i=0;i<candles.length;i++){
    if(i<p) continue;
    const slice=candles.slice(i-p,i);
    hi[i]=Math.max(...slice.map(x=>x.h));
    lo[i]=Math.min(...slice.map(x=>x.l));
  }
  return {hi,lo};
}
function atr(candles,p=14){
  const out=new Array(candles.length).fill(null);
  let prev=null, seed=0;
  const tr=(i)=>{
    const c=candles[i];
    const pc=i>0?candles[i-1].c:c.c;
    return Math.max(c.h-c.l, Math.abs(c.h-pc), Math.abs(c.l-pc));
  };
  for(let i=0;i<candles.length;i++){
    const t=tr(i);
    if(i<p){ seed+=t; continue; }
    if(i===p){ prev=(seed+t)/p; out[i]=prev; }
    else{ prev=((prev*(p-1))+t)/p; out[i]=prev; }
  }
  return out;
}
function indicators(candles){
  const closes=candles.map(x=>x.c);
  return {
    closes,
    ema9: ema(closes,9),
    ema21: ema(closes,21),
    ema50: ema(closes,50),
    rsi: rsi(closes,14),
    macd: macd(closes,12,26,9),
    bb: bollinger(closes,20,2),
    don: donchian(candles,20),
    atr: atr(candles,14),
  };
}
</script>
<!-- Parte 2/2 -->
<script>
/* =========================
   STRATEGIES
========================= */
function strat_EMA_RSI(i, ind){
  const {ema9, ema21, rsi} = ind;
  if(ema9[i]==null||ema21[i]==null||rsi[i]==null||ema9[i-1]==null||ema21[i-1]==null) return null;
  const crossUp = ema9[i-1]<=ema21[i-1] && ema9[i]>ema21[i];
  const crossDn = ema9[i-1]>=ema21[i-1] && ema9[i]<ema21[i];
  let enter=null;
  if(crossUp && rsi[i]>50) enter="BUY";
  if(crossDn && rsi[i]<50) enter="SELL";
  return {enter, exitBuy:(crossDn||rsi[i]<45), exitSell:(crossUp||rsi[i]>55)};
}
function strat_MACD(i, ind){
  const m=ind.macd;
  if(m.line[i]==null||m.signal[i]==null||m.line[i-1]==null||m.signal[i-1]==null) return null;
  const up = m.line[i-1]<=m.signal[i-1] && m.line[i]>m.signal[i];
  const dn = m.line[i-1]>=m.signal[i-1] && m.line[i]<m.signal[i];
  let enter=null;
  if(up) enter="BUY";
  if(dn) enter="SELL";
  return {enter, exitBuy:dn, exitSell:up};
}
function strat_BB(i, ind){
  const {bb, rsi, closes}=ind;
  if(bb.lower[i]==null||bb.upper[i]==null||bb.mid[i]==null||rsi[i]==null) return null;
  const c=closes[i];
  let enter=null;
  if(c<bb.lower[i] && rsi[i]<40) enter="BUY";
  if(c>bb.upper[i] && rsi[i]>60) enter="SELL";
  return {enter, exitBuy:(c>=bb.mid[i]), exitSell:(c<=bb.mid[i])};
}
function strat_DON(i, ind){
  const {don, closes, ema21}=ind;
  if(don.hi[i]==null||don.lo[i]==null||ema21[i]==null) return null;
  const c=closes[i], prev=closes[i-1];
  let enter=null;
  if(prev<=don.hi[i] && c>don.hi[i] && c>ema21[i]) enter="BUY";
  if(prev>=don.lo[i] && c<don.lo[i] && c<ema21[i]) enter="SELL";
  return {enter, exitBuy:(c<ema21[i]), exitSell:(c>ema21[i])};
}
function strat_RSI_REV(i, ind){
  const {rsi}=ind;
  if(rsi[i]==null||rsi[i-1]==null) return null;
  let enter=null;
  if(rsi[i-1]<30 && rsi[i]>=30) enter="BUY";
  if(rsi[i-1]>70 && rsi[i]<=70) enter="SELL";
  return {enter, exitBuy:(rsi[i]>55), exitSell:(rsi[i]<45)};
}
const STRATS = [
  {name:"EMA+RSI", fn:strat_EMA_RSI},
  {name:"MACD", fn:strat_MACD},
  {name:"Bollinger", fn:strat_BB},
  {name:"Donchian", fn:strat_DON},
  {name:"RSI-Reversal", fn:strat_RSI_REV},
];

/* =========================
   BACKTEST
========================= */
function backtest(candles, stratFn){
  const ind = indicators(candles);
  let pos=null;
  let equity=1, peak=1, dd=0;
  let trades=0, wins=0;
  let grossWin=0, grossLossAbs=0;

  for(let i=2;i<candles.length;i++){
    const sig = stratFn(i, ind);
    if(!sig) continue;

    const price = candles[i].c;

    if(!pos){
      if(sig.enter==="BUY"||sig.enter==="SELL"){
        pos = { side:sig.enter, entry:price };
      }
      continue;
    }

    let exit=null;
    if(pos.side==="BUY"){
      if(sig.exitBuy || sig.enter==="SELL") exit=price;
    }else{
      if(sig.exitSell || sig.enter==="BUY") exit=price;
    }

    if(exit!=null){
      const pnl = (pos.side==="BUY") ? (exit-pos.entry)/pos.entry : (pos.entry-exit)/pos.entry;
      equity *= (1+pnl);
      peak = Math.max(peak, equity);
      dd = Math.max(dd, (peak-equity)/peak);

      trades++;
      if(pnl>0){ wins++; grossWin+=pnl; } else { grossLossAbs+=Math.abs(pnl); }
      pos=null;
    }
  }

  const winrate = trades? wins/trades : 0;
  const pf = grossLossAbs? grossWin/grossLossAbs : (grossWin>0?999:0);
  const ret = equity-1;
  return {trades, winrate, pf, dd, ret};
}

function score(metrics){
  const ret=metrics.ret;
  const pf=Math.min(5, metrics.pf);
  const wr=metrics.winrate;
  const dd=metrics.dd;
  return (0.40*ret)+(0.25*(pf/5))+(0.20*wr)-(0.15*dd);
}

/* =========================
   PAPER TRADING (fills)
========================= */
function feeRate(){ return 0.001; } // 0.10% por lado aproximado
function rand(a,b){ return a+Math.random()*(b-a); }

async function realisticFill(symbol, side){
  const {bid, ask} = await fetchBookTicker(symbol);
  const mid=(bid+ask)/2;
  const spreadPct = mid ? (ask-bid)/mid : 0;
  const slipPct = clamp(0.5*spreadPct + rand(0.00002,0.00015), 0.00002, 0.002);
  const fill = side==="BUY" ? ask*(1+slipPct) : bid*(1-slipPct);
  return {fill, spreadPct, slipPct};
}

/* =========================
   STATE
========================= */
const LS_KEY="AUTO_PAPER_TRADER_V2";
let RUN=false;
let timer=null;

const S = {
  startBal: 20,
  balance: 20,
  trades: [],
  positions: {}, // key -> {side, entry}
  bestPicks: [],
  lastOpt: 0
};

function save(){ localStorage.setItem(LS_KEY, JSON.stringify(S)); }
function load(){
  try{
    const raw=localStorage.getItem(LS_KEY);
    if(raw){
      const d=JSON.parse(raw);
      Object.assign(S,d);
    }
  }catch{}
}

/* =========================
   UI
========================= */
function syncUI(){
  $("kStart").textContent = fmt(S.startBal,2);
  $("kBal").textContent = fmt(S.balance,2);
  const ret=(S.balance-S.startBal)/(S.startBal||1);
  $("kRet").textContent = fmt(ret*100,2)+"%";
  $("kRet").className = "v "+(ret>=0?"good":"bad");
  $("kTrades").textContent = String(S.trades.length);
  $("lastOpt").textContent = S.lastOpt ? new Date(S.lastOpt).toLocaleString() : "—";

  $("topList").textContent = S.bestPicks.length
    ? S.bestPicks.map((p,i)=>`${i+1}) ${p.symbol}@${p.tf} ${p.strategy} score=${fmt(p.score,4)}`).join(" | ")
    : "—";

  $("optInfo").textContent = `picks=${S.bestPicks.length} | pool=auto | lastOpt=${S.lastOpt?new Date(S.lastOpt).toLocaleTimeString():"—"}`;

  const rows = S.trades.slice().reverse().slice(0,120).map(t=>{
    const cls=t.pnlPct>=0?"good":"bad";
    return `<tr>
      <td>${new Date(t.ts).toLocaleString()}</td>
      <td><span class="tag">${t.symbol}</span></td>
      <td class="mono">${t.tf}</td>
      <td>${t.strategy}</td>
      <td class="mono">${t.side}</td>
      <td class="mono ${cls}">${fmt(t.pnlPct*100,2)}%</td>
      <td class="mono">${t.reason}</td>
    </tr>`;
  }).join("");
  $("tradesTbody").innerHTML = rows;
}

/* =========================
   OPTIMIZATION (FASES)
   FAST:
     Fase 1: TOP50 x TF(1m,5m,15m,1h,4h,1d) x STRATS  -> elige TOP 12 combos
     Fase 2: SOLO esos símbolos/strats x ALL_TFS -> elige pool TOP 30
   FULL:
     TOP50 x ALL_TFS x STRATS (lento)
========================= */
async function optimize(){
  const topN = Number($("topN").value)||50;
  const limit = Math.max(250, Number($("btLimit").value)||700);
  const minTrades = Math.max(1, Number($("minTrades").value)||40);
  const maxDD = Math.max(1, Number($("maxDD").value)||35)/100;
  const mode = $("optMode").value;

  setStatus("optimizando…","warn");
  setStage("Descubriendo TOP "+topN+"…");
  setProg(0,1,"");

  const symbols = await discoverTopSymbols(topN);

  const fastTFs = ["1m","5m","15m","1h","4h","1d"].filter(x=>ALL_TFS.includes(x));
  const phaseTFs = (mode==="fast") ? fastTFs : ALL_TFS;

  // --------- Phase 1: coarse scan
  setStage("Fase 1: escaneo inicial ("+phaseTFs.length+" TFs)...");
  let total1 = symbols.length * phaseTFs.length * STRATS.length;
  let done=0;
  let coarse=[];

  for(const sym of symbols){
    for(const tf of phaseTFs){
      let candles;
      try{ candles = await fetchKlines(sym, tf, limit); }
      catch(e){ done+=STRATS.length; setProg(done,total1,`${sym}@${tf} (skip)`); continue; }

      for(const st of STRATS){
        const m = backtest(candles, st.fn);
        done++;
        setProg(done,total1,`${sym}@${tf}@${st.name}`);

        if(m.trades<minTrades) continue;
        if(m.dd>maxDD) continue;
        if(m.ret<=0) continue;

        coarse.push({symbol:sym, tf, strategy:st.name, score:score(m), metrics:m});
      }
      await sleep(35);
    }
    await sleep(40);
  }

  coarse.sort((a,b)=>b.score-a.score);
  if(!coarse.length) throw new Error("No se pudo construir pool en Fase 1 (todo filtrado o Binance bloqueado).");

  // top combos para fase 2
  const topSeeds = coarse.slice(0,12);
  const seedSyms = Array.from(new Set(topSeeds.map(x=>x.symbol)));
  const seedStrats = Array.from(new Set(topSeeds.map(x=>x.strategy)));

  // --------- Phase 2: refine scan
  const refineTFs = (mode==="fast") ? ALL_TFS : ALL_TFS;
  setStage("Fase 2: refinando ("+seedSyms.length+" símbolos, "+refineTFs.length+" TFs)…");

  let total2 = seedSyms.length * refineTFs.length * seedStrats.length;
  done=0;
  let refined=[];

  for(const sym of seedSyms){
    for(const tf of refineTFs){
      let candles;
      try{ candles = await fetchKlines(sym, tf, limit); }
      catch(e){ done+=seedStrats.length; setProg(done,total2,`${sym}@${tf} (skip)`); continue; }

      for(const stratName of seedStrats){
        const st = STRATS.find(x=>x.name===stratName);
        const m = backtest(candles, st.fn);
        done++;
        setProg(done,total2,`${sym}@${tf}@${st.name}`);

        if(m.trades<minTrades) continue;
        if(m.dd>maxDD) continue;
        if(m.ret<=0) continue;

        refined.push({symbol:sym, tf, strategy:st.name, score:score(m), metrics:m});
      }
      await sleep(35);
    }
    await sleep(40);
  }

  refined.sort((a,b)=>b.score-a.score);
  const pool = refined.slice(0,30);
  const picks = pool.slice(0,3);

  if(!picks.length) throw new Error("Optimización: no se encontraron picks finales.");

  S.bestPicks = picks;
  S.lastOpt = Date.now();
  save();
  syncUI();
  setStatus("operando (paper)","good");
  setStage("Listo ✅");
  setProg(1,1,"");

  log("TOP3: "+picks.map(p=>`${p.symbol}@${p.tf} ${p.strategy}`).join(" | "));
  notify("Optimización lista", "TOP3 actualizado (paper).");
}

/* =========================
   LIVE TICK
========================= */
function pickKey(p){ return `${p.symbol}@${p.tf}@${p.strategy}`; }

async function liveTick(){
  if(!RUN) return;
  if(!S.bestPicks.length){
    log("No hay TOP3, reoptimizando…");
    await optimize();
    return;
  }

  for(const pick of S.bestPicks){
    const key = pickKey(pick);
    let candles;
    try{ candles = await fetchKlines(pick.symbol, pick.tf, 220); }
    catch(e){ log(`LIVE skip ${key}: ${e.message||e}`); continue; }

    const ind = indicators(candles);
    const i = candles.length-1;
    const st = STRATS.find(s=>s.name===pick.strategy);
    const sig = st.fn(i, ind);
    if(!sig) continue;

    const pos = S.positions[key];

    // open
    if(!pos && sig.enter){
      const fill = await realisticFill(pick.symbol, sig.enter);
      S.positions[key] = { side:sig.enter, entry: fill.fill };
      log(`OPEN ${key} ${sig.enter} @ ${fmt(fill.fill,6)} (spr ${(fill.spreadPct*100).toFixed(3)}% slip ${(fill.slipPct*100).toFixed(3)}%)`);
      continue;
    }

    // close
    if(pos){
      const wantClose =
        (pos.side==="BUY"  && (sig.exitBuy || sig.enter==="SELL")) ||
        (pos.side==="SELL" && (sig.exitSell || sig.enter==="BUY"));

      if(wantClose){
        const exitSide = pos.side==="BUY" ? "SELL" : "BUY";
        const fill = await realisticFill(pick.symbol, exitSide);
        const move = (pos.side==="BUY") ? (fill.fill-pos.entry)/pos.entry : (pos.entry-fill.fill)/pos.entry;
        const fees = feeRate()*2;
        const pnlPct = move - fees;

        S.balance *= (1 + pnlPct);

        S.trades.push({
          ts: Date.now(),
          symbol: pick.symbol,
          tf: pick.tf,
          strategy: pick.strategy,
          side: pos.side,
          pnlPct,
          reason: "SignalExit",
        });

        delete S.positions[key];
        save();
        syncUI();

        log(`CLOSE ${key} pnl=${fmt(pnlPct*100,2)}% bal=$${fmt(S.balance,2)}`);
        notify("Trade cerrado", `${pick.symbol} ${fmt(pnlPct*100,2)}%`);
      }
    }

    await sleep(180);
  }

  // reopt diaria
  if($("reoptDaily").value==="yes"){
    if(S.lastOpt && (Date.now()-S.lastOpt) > (24*60*60*1000)){
      log("Reopt diaria…");
      await optimize();
    }
  }
}

/* =========================
   START/STOP
========================= */
async function start(){
  if(RUN) return;
  RUN=true;
  $("btnStart").disabled=true;
  $("btnStop").disabled=false;

  const startBal = Math.max(1, Number($("startBal").value)||20);
  if(!S.startBal || S.startBal<=0){ S.startBal=startBal; }
  if(!S.balance || S.balance<=0){ S.balance=startBal; }
  save(); syncUI();

  setStatus("iniciando…","warn");
  log("START");

  try{
    await optimize();
  }catch(e){
    setStatus("error","bad");
    setStage("Error ❌");
    log("ERROR optimize: "+(e.message||e));
    RUN=false;
    $("btnStart").disabled=false;
    $("btnStop").disabled=true;
    return;
  }

  const poll = Math.max(10, Number($("pollSec").value)||60)*1000;
  timer = setInterval(()=>{ liveTick().catch(err=>log("Tick error: "+(err.message||err))); }, poll);

  // tick inmediato
  liveTick().catch(err=>log("Tick error: "+(err.message||err)));
}

function stop(){
  RUN=false;
  $("btnStart").disabled=false;
  $("btnStop").disabled=true;
  if(timer) clearInterval(timer);
  timer=null;
  setStatus("detenido","warn");
  setStage("—");
  log("STOP");
}

/* =========================
   BOOT
========================= */
load();
syncUI();
setStatus("idle","warn");
setStage("—");
setProg(0,1,"");
log("Listo. Presiona INICIAR.");

$("btnStart").addEventListener("click", start);
$("btnStop").addEventListener("click", stop);
$("btnNotify").addEventListener("click", askNotifications);
</script>

</body>
</html>
<!-- FIN -->
