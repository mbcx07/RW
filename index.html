<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador Multi-Activos ‚Äî Backtest (TODOS TF) | Estrategias Simult√°neas</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#0f1a33; --panel2:#0c1730;
      --text:#e8eefc; --muted:#a9b7e5; --line:#24335f;
      --accent:#7c5cff; --good:#19d3a2; --bad:#ff5c7a; --warn:#ffcc66;
      --shadow: 0 10px 24px rgba(0,0,0,.35);
      --r:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans);
      background:radial-gradient(1200px 700px at 20% 0%, #111d3b 0%, var(--bg) 55%, #070b14 100%);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:5;
      backdrop-filter: blur(10px);
      background: rgba(11,18,32,.75);
      border-bottom:1px solid rgba(36,51,95,.55);
    }
    .wrap{max-width:1200px; margin:0 auto; padding:14px;}
    .topbar{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .brand{display:flex; align-items:center; gap:10px; user-select:none;}
    .logo{
      width:36px;height:36px;border-radius:12px;
      background: linear-gradient(135deg, #7c5cff 0%, #19d3a2 100%);
      box-shadow: 0 10px 24px rgba(124,92,255,.25);
    }
    .brand h1{font-size:16px; margin:0; letter-spacing:.2px}
    .brand .sub{font-size:12px; color:var(--muted); margin-top:2px}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:12px; align-items:start;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
    .card{
      background: linear-gradient(180deg, rgba(15,26,51,.92) 0%, rgba(12,23,48,.92) 100%);
      border:1px solid rgba(36,51,95,.65);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .head{
      padding:12px;
      border-bottom:1px solid rgba(36,51,95,.55);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card h2{margin:0; font-size:13px; letter-spacing:.3px; color: var(--muted);}
    .card .body{padding:12px}
    label{font-size:11px; color:var(--muted); display:block; margin-bottom:6px}
    input, select, textarea{
      width:100%;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(36,51,95,.75);
      background: rgba(11,18,32,.55);
      color: var(--text);
      outline:none;
    }
    textarea{min-height:120px; resize:vertical; font-family:var(--mono); font-size:12px}
    .btn{
      border:1px solid rgba(36,51,95,.75);
      background: rgba(124,92,255,.14);
      color: var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      transition:.15s ease;
      font-weight:700;
      box-shadow: 0 8px 18px rgba(124,92,255,.12);
    }
    .btn:hover{transform: translateY(-1px); background: rgba(124,92,255,.20)}
    .btn:active{transform: translateY(0px)}
    .btn.secondary{background: rgba(25,211,162,.12); box-shadow: 0 8px 18px rgba(25,211,162,.10)}
    .btn.danger{background: rgba(255,92,122,.12); box-shadow: 0 8px 18px rgba(255,92,122,.10)}
    .btn.ghost{background: rgba(11,18,32,.35); box-shadow:none}
    .btn:disabled{opacity:.5; cursor:not-allowed; transform:none}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:stretch}
    .inputs{display:grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap:10px;}
    @media (max-width: 980px){ .inputs{grid-template-columns: repeat(2, minmax(0, 1fr));} }
    .pill{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(36,51,95,.65);
      background: rgba(11,18,32,.5);
      color:var(--muted);
      display:inline-flex; align-items:center; gap:8px;
      font-family: var(--mono);
      white-space:nowrap;
    }
    .hr{height:1px; background: rgba(36,51,95,.55); margin:12px 0}
    .hint{font-size:12px; color:rgba(169,183,229,.78); line-height:1.35}
    .note{
      font-size:12px; color:rgba(169,183,229,.78);
      border-left:3px solid rgba(124,92,255,.6);
      padding:10px 12px; background: rgba(11,18,32,.35); border-radius:14px;
    }
    .kpis{display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap:10px;}
    @media (max-width: 980px){ .kpis{grid-template-columns: repeat(2, minmax(0, 1fr))} }
    .kpi{
      padding:10px; border-radius:16px;
      border:1px solid rgba(36,51,95,.65);
      background: rgba(11,18,32,.35);
    }
    .kpi .t{font-size:11px; color:var(--muted)}
    .kpi .v{font-family:var(--mono); font-size:15px; margin-top:4px}
    .good{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th, td{padding:8px 8px; border-bottom:1px solid rgba(36,51,95,.45); vertical-align:top}
    th{color:var(--muted); font-weight:700; text-align:left}
    .tag{
      font-family:var(--mono);
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(36,51,95,.65);
      background: rgba(11,18,32,.35);
      display:inline-block;
      white-space:nowrap;
    }
    .small{font-size:12px}
    #toasts{
      position:fixed; right:14px; bottom:14px; z-index:1000;
      display:flex; flex-direction:column; gap:10px; width:min(420px, calc(100vw - 28px));
    }
    .toast{
      border-radius:18px; padding:12px 12px;
      border:1px solid rgba(36,51,95,.75);
      background: rgba(15,26,51,.92);
      box-shadow: var(--shadow);
    }
    .toast .title{font-weight:900; letter-spacing:.2px}
    .toast .msg{color:var(--muted); font-size:12px; margin-top:4px; line-height:1.25}
    .tfGrid{display:grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap:10px;}
    @media (max-width: 980px){ .tfGrid{grid-template-columns: repeat(3, minmax(0, 1fr));} }
    .tfChip{
      border:1px solid rgba(36,51,95,.65);
      border-radius:14px;
      padding:8px 10px;
      background: rgba(11,18,32,.35);
      cursor:pointer;
      user-select:none;
      display:flex; gap:8px; align-items:center; justify-content:flex-start;
      font-size:12px;
      color: var(--muted);
    }
    .tfChip input{width:auto}
    .mono{font-family:var(--mono)}
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Simulador Multi-Activos (Paper Trading)</h1>
          <div class="sub">Backtest simult√°neo ‚Äî TODOS los timeframes ‚Äî sin comisiones/spread</div>
        </div>
      </div>
      <div class="row">
        <span id="statusPill" class="pill">‚óè listo</span>
        <button id="btnResolve" class="btn ghost">Resolver s√≠mbolos</button>
        <button id="btnRun" class="btn secondary">Correr Backtest</button>
        <button id="btnStop" class="btn danger" disabled>Detener</button>
        <button id="btnExport" class="btn ghost" disabled>Exportar JSON</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- CONFIG -->
    <section class="card">
      <div class="head">
        <h2>Configuraci√≥n</h2>
        <span class="pill">Datos: Binance (cripto) + TwelveData (divisas/XAU/√≠ndices)</span>
      </div>
      <div class="body">

        <div class="inputs">
          <div>
            <label>Velas por s√≠mbolo (por TF)</label>
            <input id="limit" type="number" min="200" step="100" value="800" />
          </div>
          <div>
            <label>Riesgo por trade (solo simulaci√≥n)</label>
            <select id="risk">
              <option value="0.005">0.5%</option>
              <option value="0.01" selected>1.0%</option>
              <option value="0.02">2.0%</option>
            </select>
          </div>
          <div>
            <label>SL</label>
            <select id="slMode">
              <option value="atr" selected>ATR(14) x 1.5</option>
              <option value="pct">1.0%</option>
            </select>
          </div>
          <div>
            <label>TP</label>
            <select id="tpMode">
              <option value="rr" selected>R:R 1:2</option>
              <option value="pct">2.0%</option>
            </select>
          </div>
          <div>
            <label>Votos (Ensemble)</label>
            <select id="ensembleVotes">
              <option value="2" selected>2 estrategias alineadas</option>
              <option value="3">3 estrategias alineadas</option>
              <option value="4">4 estrategias alineadas</option>
            </select>
          </div>
          <div>
            <label>Modo datos</label>
            <select id="dataMode">
              <option value="auto" selected>Auto</option>
              <option value="binanceOnly">Solo Binance (solo cripto)</option>
              <option value="twelveOnly">Solo TwelveData</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <label>Timeframes (selecciona TODOS)</label>
        <div class="tfGrid" id="tfGrid"></div>
        <div class="hint">Por defecto vienen todos activados (como pediste).</div>

        <div class="hr"></div>

        <label>Lista de s√≠mbolos (uno por l√≠nea)</label>
        <textarea id="symbols">BTCUSDT
ETHUSDT
XRPUSDT
XAUUSD
EURUSD
GBPUSD
NAS100</textarea>

        <div class="hint">
          Normalizaci√≥n autom√°tica:
          <span class="tag">EURUSD‚ÜíEUR/USD</span>,
          <span class="tag">GBPUSD‚ÜíGBP/USD</span>,
          <span class="tag">XAUUSD‚ÜíXAU/USD</span>.
          NAS100 se intenta resolver v√≠a TwelveData symbol_search.
        </div>

        <div class="hr"></div>

        <div class="row" style="align-items:flex-end;">
          <div style="flex:1">
            <label>API Key TwelveData (divisas/XAU/√≠ndices)</label>
            <input id="twelveKey" value="5a95ae8e4a0946c885464dc1f068ff39" />
            <div class="hint">
              Si haces repo p√∫blico, evita dejar la key visible. (Para investigaci√≥n privada est√° ok.)
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <details open>
          <summary class="hint">‚öôÔ∏è Estrategias activas (todas)</summary>
          <div class="hr"></div>
          <div class="inputs" style="grid-template-columns: repeat(2, minmax(0, 1fr));">
            <label class="pill" style="cursor:pointer;"><input id="sEMA" type="checkbox" checked style="margin-right:6px"> EMA+RSI (tendencia)</label>
            <label class="pill" style="cursor:pointer;"><input id="sMACD" type="checkbox" checked style="margin-right:6px"> MACD trend</label>
            <label class="pill" style="cursor:pointer;"><input id="sBB" type="checkbox" checked style="margin-right:6px"> Bollinger mean-reversion</label>
            <label class="pill" style="cursor:pointer;"><input id="sBR" type="checkbox" checked style="margin-right:6px"> Breakout + pullback (S/R)</label>
            <label class="pill" style="cursor:pointer;"><input id="sC" type="checkbox" checked style="margin-right:6px"> Patrones (velas)</label>
          </div>
        </details>

        <div class="note" style="margin-top:12px">
          Backtest aproximado: sin comisiones, slippage ni spreads (como pediste).
          Cuando veamos rentabilidad y estabilidad por timeframe/s√≠mbolo, pasamos a simulaci√≥n ‚Äúm√°s real‚Äù (spread) y reci√©n despu√©s automatizaci√≥n real.
        </div>
      </div>
    </section>

    <!-- RESULTADOS -->
    <aside class="card">
      <div class="head">
        <h2>Resultados</h2>
        <div class="row">
          <span id="prog" class="pill">0/0</span>
          <span id="err" class="pill">errores: 0</span>
        </div>
      </div>
      <div class="body">

        <div class="kpis">
          <div class="kpi">
            <div class="t">S√≠mbolos</div>
            <div id="kSyms" class="v">‚Äî</div>
          </div>
          <div class="kpi">
            <div class="t">Timeframes</div>
            <div id="kTFs" class="v">‚Äî</div>
          </div>
          <div class="kpi">
            <div class="t">Estrategias activas</div>
            <div id="kStrats" class="v">‚Äî</div>
          </div>
          <div class="kpi">
            <div class="t">Ensemble promedio (Ret / DD)</div>
            <div id="kEns" class="v">‚Äî</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="hint">Tabla por s√≠mbolo + TF + estrategia</div>
          <span class="pill">Orden: mejor retorno</span>
        </div>

        <div style="max-height:520px; overflow:auto; margin-top:10px;">
          <table id="tbl">
            <thead>
              <tr>
                <th>S√≠mbolo</th>
                <th>TF</th>
                <th>Estrategia</th>
                <th>Trades</th>
                <th>Win%</th>
                <th>PF</th>
                <th>DD%</th>
                <th>Ret%</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="hr"></div>

        <details>
          <summary class="hint">üì¶ Log / Debug</summary>
          <div class="hr"></div>
          <textarea id="log" placeholder="Eventos, resoluci√≥n de s√≠mbolos, errores y progreso..." style="min-height:160px"></textarea>
        </details>
      </div>
    </aside>
  </div>
</main>

<div id="toasts"></div>

<script>
/* =========================
   Utilidades
   ========================= */
const $ = (q, el=document) => el.querySelector(q);
const fmt = (n,d=2)=> Number.isFinite(n) ? n.toFixed(d) : "‚Äî";
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
const nowISO = ()=> new Date().toISOString();
const isCrypto = (sym)=> /USDT$|BUSD$|USDC$|BTC$|ETH$/.test(sym.toUpperCase()) && !sym.includes("/");
function toast(title, msg, kind="good"){
  const el = document.createElement("div");
  el.className = "toast";
  const color = kind==="good" ? "rgba(25,211,162,.55)" : kind==="bad" ? "rgba(255,92,122,.55)" : "rgba(255,204,102,.55)";
  el.style.borderColor = color;
  el.innerHTML = `<div class="title">${escapeHtml(title)}</div><div class="msg">${escapeHtml(msg)}</div>`;
  $("#toasts").appendChild(el);
  setTimeout(()=>el.remove(), 5200);
}
function escapeHtml(s=""){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function log(msg){
  const box = $("#log");
  box.value = `[${new Date().toLocaleTimeString()}] ${msg}\n` + box.value;
}
function setStatus(text, color){
  const p=$("#statusPill");
  p.textContent="‚óè "+text;
  p.style.color = color || "rgba(169,183,229,.95)";
}

/* =========================
   Timeframes UI
   ========================= */
const ALL_TFS = ["1m","5m","15m","1h","4h","1d"];
function renderTFGrid(){
  const grid = $("#tfGrid");
  grid.innerHTML = "";
  for(const tf of ALL_TFS){
    const id = `tf_${tf}`;
    const div = document.createElement("label");
    div.className = "tfChip";
    div.innerHTML = `<input type="checkbox" id="${id}" checked> <span class="mono">${tf}</span>`;
    grid.appendChild(div);
  }
}
function selectedTFs(){
  return ALL_TFS.filter(tf => $(`#tf_${tf}`)?.checked);
}

/* =========================
   Datos: Binance + TwelveData
   ========================= */
async function fetchBinanceKlines(symbol, interval, limit){
  const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error(`Binance klines error (${res.status})`);
  const data = await res.json();
  return data.map(k=>({
    time: Math.floor(k[0]/1000),
    open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5]
  }));
}
function mapTfToTwelve(tf){
  const m = { "1m":"1min","5m":"5min","15m":"15min","1h":"1h","4h":"4h","1d":"1day" };
  return m[tf] || "15min";
}
async function fetchTwelveTimeSeries(symbol, tf, limit, apiKey){
  const interval = mapTfToTwelve(tf);
  const url = `https://api.twelvedata.com/time_series?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&outputsize=${limit}&apikey=${encodeURIComponent(apiKey)}&format=JSON`;
  const res = await fetch(url);
  const data = await res.json();
  if(data.status === "error") throw new Error(`TwelveData: ${data.message || "error"}`);
  const values = (data.values || []).slice().reverse();
  return values.map(v=>({
    time: Math.floor(new Date(v.datetime).getTime()/1000),
    open:+v.open, high:+v.high, low:+v.low, close:+v.close,
    volume: v.volume ? +v.volume : 0
  }));
}
async function twelveSymbolSearch(query, apiKey){
  const url = `https://api.twelvedata.com/symbol_search?symbol=${encodeURIComponent(query)}&apikey=${encodeURIComponent(apiKey)}`;
  const res = await fetch(url);
  const data = await res.json();
  if(data.status === "error") throw new Error(`symbol_search: ${data.message || "error"}`);
  return data.data || [];
}
async function fetchCandles(sym, tf, limit, mode, twelveKey){
  const crypto = isCrypto(sym);
  if(mode==="binanceOnly"){
    if(!crypto) throw new Error("Modo BinanceOnly: s√≠mbolo no cripto.");
    return await fetchBinanceKlines(sym, tf, limit);
  }
  if(mode==="twelveOnly"){
    if(!twelveKey) throw new Error("Falta API key TwelveData.");
    return await fetchTwelveTimeSeries(sym, tf, limit, twelveKey);
  }
  // auto
  if(crypto) return await fetchBinanceKlines(sym, tf, limit);
  if(!twelveKey) throw new Error("Falta API key TwelveData para divisas/XAU/√≠ndices.");
  return await fetchTwelveTimeSeries(sym, tf, limit, twelveKey);
}

/* =========================
   Normalizaci√≥n + Resoluci√≥n de s√≠mbolos
   ========================= */
function normalizeForexPair(sym){
  // EURUSD -> EUR/USD, GBPUSD -> GBP/USD, XAUUSD -> XAU/USD, etc.
  const s = sym.toUpperCase().trim();
  if(s.includes("/")) return s;
  if(/^[A-Z]{6}$/.test(s)) return `${s.slice(0,3)}/${s.slice(3,6)}`;
  return s;
}
async function resolveSymbol(sym, mode, twelveKey){
  let s = sym.trim().toUpperCase();
  if(!s) return null;

  // Cripto: Binance expects no slash
  if(isCrypto(s)) return { raw:sym, resolved:s, provider:"binance" };

  // XAUUSD / EURUSD / GBPUSD normalization
  const normalized = normalizeForexPair(s);
  s = normalized;

  // NAS100 special case: try symbol_search if TwelveData enabled
  if(s==="NAS100" || s==="NAS100USD" || s==="NAS100/US" || s==="NAS100/USD"){
    if(mode!=="binanceOnly" && twelveKey){
      try{
        const candidates = [
          ...await twelveSymbolSearch("NASDAQ 100", twelveKey),
          ...await twelveSymbolSearch("NAS100", twelveKey),
          ...await twelveSymbolSearch("NDX", twelveKey),
        ];

        // Heur√≠stica: preferir type Index / Indices; si no, tomar el primero
        const pick = candidates.find(c => String(c.instrument_type||"").toLowerCase().includes("index"))
                  || candidates.find(c => String(c.type||"").toLowerCase().includes("index"))
                  || candidates[0];

        if(pick?.symbol){
          log(`NAS100 resuelto v√≠a symbol_search -> ${pick.symbol} (${pick.instrument_type || pick.type || "?"})`);
          return { raw:sym, resolved: pick.symbol.toUpperCase(), provider:"twelve", meta:pick };
        }
      }catch(e){
        log(`symbol_search fall√≥ para NAS100: ${e.message || e}`);
      }
    }
    // Fallback (no garantizado): NDX
    log("NAS100 fallback -> NDX (si falla, usa Resolver s√≠mbolos y revisa log).");
    return { raw:sym, resolved:"NDX", provider:"twelve" };
  }

  // Para todo lo dem√°s no-cripto: TwelveData (auto/twelveOnly)
  return { raw:sym, resolved:s, provider:"twelve" };
}

async function resolveAllSymbols(){
  const mode = $("#dataMode").value;
  const key = $("#twelveKey").value.trim();
  const raw = $("#symbols").value.split("\n").map(x=>x.trim()).filter(Boolean);

  const out = [];
  for(const sym of raw){
    const r = await resolveSymbol(sym, mode, key);
    if(r) out.push(r);
  }

  // Reescribe textarea con resolved (solo s√≠mbolo)
  $("#symbols").value = out.map(x=>x.resolved).join("\n");
  toast("S√≠mbolos", "Normalizados/Resueltos. Revisa el log si NAS100 cambi√≥.", "good");
  log("S√≠mbolos finales: " + out.map(x=>x.resolved).join(", "));
}

/* =========================
   Indicadores
   ========================= */
function sma(values, p){
  const out = Array(values.length).fill(null);
  let sum=0;
  for(let i=0;i<values.length;i++){
    sum += values[i];
    if(i>=p) sum -= values[i-p];
    if(i>=p-1) out[i]=sum/p;
  }
  return out;
}
function ema(values, p){
  const out = Array(values.length).fill(null);
  const k = 2/(p+1);
  let prev=null;
  for(let i=0;i<values.length;i++){
    const v = values[i];
    if(prev===null){
      if(i>=p-1){
        const seed = values.slice(i-p+1,i+1).reduce((a,b)=>a+b,0)/p;
        prev = seed; out[i]=seed;
      }
    }else{
      prev = v*k + prev*(1-k);
      out[i]=prev;
    }
  }
  return out;
}
function rsi(closes, p=14){
  const out = Array(closes.length).fill(null);
  let avgG=null, avgL=null;
  for(let i=1;i<closes.length;i++){
    const ch = closes[i]-closes[i-1];
    const g = Math.max(ch,0);
    const l = Math.max(-ch,0);
    if(i<p){
      avgG = (avgG??0)+g;
      avgL = (avgL??0)+l;
      continue;
    }
    if(i===p){
      avgG = ((avgG??0)+g)/p;
      avgL = ((avgL??0)+l)/p;
    }else{
      avgG = (avgG*(p-1)+g)/p;
      avgL = (avgL*(p-1)+l)/p;
    }
    const rs = (avgL===0) ? 999 : avgG/avgL;
    out[i] = 100 - (100/(1+rs));
  }
  return out;
}
function macd(closes, fast=12, slow=26, sig=9){
  const ef = ema(closes, fast);
  const es = ema(closes, slow);
  const line = closes.map((_,i)=> (ef[i]==null||es[i]==null)?null:(ef[i]-es[i]));
  const filled = line.map(v=>v==null?0:v);
  const signal = ema(filled, sig).map((v,i)=> line[i]==null?null:v);
  const hist = line.map((v,i)=> (v==null||signal[i]==null)?null:(v-signal[i]));
  return { line, signal, hist };
}
function bollinger(closes, p=20, m=2){
  const mid = sma(closes,p);
  const up = Array(closes.length).fill(null);
  const lo = Array(closes.length).fill(null);
  for(let i=0;i<closes.length;i++){
    if(i<p-1) continue;
    const slice = closes.slice(i-p+1,i+1);
    const mu = mid[i];
    const varc = slice.reduce((a,v)=>a+(v-mu)*(v-mu),0)/p;
    const sd = Math.sqrt(varc);
    up[i]=mu+m*sd; lo[i]=mu-m*sd;
  }
  return { mid, upper:up, lower:lo };
}
function atr(candles, p=14){
  const out = Array(candles.length).fill(null);
  let prev=null;
  const tr = (i)=>{
    const c=candles[i];
    const pc = i>0?candles[i-1].close:c.close;
    return Math.max(c.high-c.low, Math.abs(c.high-pc), Math.abs(c.low-pc));
  };
  let seed=0;
  for(let i=0;i<candles.length;i++){
    const t=tr(i);
    if(i<p){ seed+=t; continue; }
    if(i===p){
      prev=(seed+t)/p;
      out[i]=prev;
    }else{
      prev=((prev*(p-1))+t)/p;
      out[i]=prev;
    }
  }
  return out;
}
function swings(candles, lb=3){
  const hi=Array(candles.length).fill(null);
  const lo=Array(candles.length).fill(null);
  for(let i=lb;i<candles.length-lb;i++){
    const h=candles[i].high, l=candles[i].low;
    let isH=true,isL=true;
    for(let j=1;j<=lb;j++){
      if(candles[i-j].high>=h || candles[i+j].high>=h) isH=false;
      if(candles[i-j].low<=l  || candles[i+j].low<=l)  isL=false;
    }
    if(isH) hi[i]=h;
    if(isL) lo[i]=l;
  }
  return { hi, lo };
}
function candlePatterns(candles){
  const out = Array(candles.length).fill(null).map(()=>({}));
  for(let i=1;i<candles.length;i++){
    const c=candles[i], p=candles[i-1];
    const body=Math.abs(c.close-c.open);
    const range=(c.high-c.low)||1e-9;
    const upper=c.high-Math.max(c.open,c.close);
    const lower=Math.min(c.open,c.close)-c.low;

    out[i].doji = (body/range)<0.12;
    out[i].hammer = (lower/range)>0.55 && (upper/range)<0.20 && (body/range)<0.35;

    const pH=Math.max(p.open,p.close), pL=Math.min(p.open,p.close);
    const cH=Math.max(c.open,c.close), cL=Math.min(c.open,c.close);
    out[i].engulfBull = (c.close>c.open)&&(p.close<p.open)&&(cH>=pH)&&(cL<=pL);
    out[i].engulfBear = (c.close<c.open)&&(p.close>p.open)&&(cH>=pH)&&(cL<=pL);
  }
  return out;
}
function computeIndicators(candles){
  const closes = candles.map(c=>c.close);
  return {
    ema9: ema(closes,9),
    ema21: ema(closes,21),
    ema50: ema(closes,50),
    ema200: ema(closes,200),
    rsi: rsi(closes,14),
    macd: macd(closes,12,26,9),
    bb: bollinger(closes,20,2),
    atr: atr(candles,14),
    sw: swings(candles,3),
    patt: candlePatterns(candles),
    closes
  };
}

/* =========================
   Estrategias
   ========================= */
function sltp(price, atr14, slMode, tpMode){
  let slDist = (slMode==="atr") ? (atr14*1.5) : (price*0.01);
  let tpDist = (tpMode==="rr") ? (slDist*2) : (price*0.02);
  return { slDist, tpDist };
}
function stratEMA(i, ind){
  const { ema9, ema21, ema50, ema200, rsi } = ind;
  const a9=ema9[i], a21=ema21[i], a50=ema50[i], a200=ema200[i];
  if(a9==null||a21==null||a50==null||a200==null||rsi[i]==null) return null;

  const crossUp = ema9[i-1]!=null && ema21[i-1]!=null && ema9[i-1]<=ema21[i-1] && ema9[i]>ema21[i];
  const crossDn = ema9[i-1]!=null && ema21[i-1]!=null && ema9[i-1]>=ema21[i-1] && ema9[i]<ema21[i];
  const trendUp = a50>a200;
  const trendDn = a50<a200;

  let enter=null;
  if(crossUp && trendUp && rsi[i]>50) enter="BUY";
  if(crossDn && trendDn && rsi[i]<50) enter="SELL";

  const exitBuy = (crossDn || rsi[i]<45);
  const exitSell = (crossUp || rsi[i]>55);

  return { enter, exitBuy, exitSell };
}
function stratMACD(i, ind){
  const { macd, ema50, ema200 } = ind;
  if(macd.line[i]==null||macd.signal[i]==null||ema50[i]==null||ema200[i]==null) return null;
  const trendUp = ema50[i]>ema200[i];
  const trendDn = ema50[i]<ema200[i];

  const up = macd.line[i-1]<=macd.signal[i-1] && macd.line[i]>macd.signal[i];
  const dn = macd.line[i-1]>=macd.signal[i-1] && macd.line[i]<macd.signal[i];

  let enter=null;
  if(up && trendUp) enter="BUY";
  if(dn && trendDn) enter="SELL";

  const exitBuy = dn;
  const exitSell = up;

  return { enter, exitBuy, exitSell };
}
function stratBB(i, ind){
  const { bb, rsi, closes } = ind;
  if(bb.lower[i]==null||bb.upper[i]==null||bb.mid[i]==null||rsi[i]==null) return null;
  const c = closes[i];
  let enter=null;
  if(c < bb.lower[i] && rsi[i] < 40) enter="BUY";
  if(c > bb.upper[i] && rsi[i] > 60) enter="SELL";
  const exitBuy = c >= bb.mid[i];
  const exitSell = c <= bb.mid[i];
  return { enter, exitBuy, exitSell };
}
function stratBreakoutPullback(i, ind){
  const { sw, closes, ema21 } = ind;
  if(i<10 || ema21[i]==null) return null;

  let lastSH=null, lastSL=null;
  for(let k=i-1;k>=0;k--){
    if(lastSH==null && sw.hi[k]!=null) lastSH = sw.hi[k];
    if(lastSL==null && sw.lo[k]!=null) lastSL = sw.lo[k];
    if(lastSH!=null && lastSL!=null) break;
  }
  if(lastSH==null && lastSL==null) return null;

  const c = closes[i];
  const prev = closes[i-1];
  let enter=null;

  if(lastSH!=null && prev<=lastSH && c>lastSH && c>ema21[i]) enter="BUY";
  if(lastSL!=null && prev>=lastSL && c<lastSL && c<ema21[i]) enter="SELL";

  const exitBuy = c < ema21[i];
  const exitSell = c > ema21[i];

  return { enter, exitBuy, exitSell };
}
function stratCandles(i, ind){
  const { patt, rsi } = ind;
  if(!patt[i] || rsi[i]==null) return null;

  let enter=null;
  if(patt[i].engulfBull || patt[i].hammer){
    if(rsi[i]>45) enter="BUY";
  }
  if(patt[i].engulfBear){
    if(rsi[i]<55) enter="SELL";
  }

  const exitBuy = patt[i].engulfBear || (rsi[i]<45);
  const exitSell = patt[i].engulfBull || (rsi[i]>55);

  return { enter, exitBuy, exitSell };
}

/* =========================
   Backtest
   ========================= */
function backtestOne(candles, ind, stratFn, cfg){
  let pos=null; // { side, entry, sl, tp }
  let equity=1, peak=1, dd=0;
  const trades=[];
  const risk = Number(cfg.risk);

  for(let i=2;i<candles.length;i++){
    const price = candles[i].close;
    const a = ind.atr[i] ?? 0;
    const sig = stratFn(i, ind, candles);
    if(!sig) continue;

    if(!pos){
      if(sig.enter==="BUY" || sig.enter==="SELL"){
        const { slDist, tpDist } = sltp(price, a, cfg.slMode, cfg.tpMode);
        const sl = (sig.enter==="BUY") ? (price - slDist) : (price + slDist);
        const tp = (sig.enter==="BUY") ? (price + tpDist) : (price - tpDist);
        pos = { side:sig.enter, entry:price, sl, tp };
      }
      continue;
    }

    const hi=candles[i].high, lo=candles[i].low;
    let exit=null;

    if(pos.side==="BUY"){
      if(lo <= pos.sl) exit = pos.sl;
      else if(hi >= pos.tp) exit = pos.tp;
      else if(sig.exitBuy) exit = price;
      else if(sig.enter==="SELL") exit = price;
    }else{
      if(hi >= pos.sl) exit = pos.sl;
      else if(lo <= pos.tp) exit = pos.tp;
      else if(sig.exitSell) exit = price;
      else if(sig.enter==="BUY") exit = price;
    }

    if(exit!=null){
      const pnl = (pos.side==="BUY") ? (exit-pos.entry)/pos.entry : (pos.entry-exit)/pos.entry;

      // sizing simple basado en riesgo/sl% (cap a 5x)
      const slPct = Math.abs((pos.sl - pos.entry)/pos.entry) || 0.001;
      const leverageLike = Math.min(5, risk / slPct);
      const adjPnl = pnl * leverageLike;

      equity *= (1 + adjPnl);
      peak = Math.max(peak, equity);
      dd = Math.max(dd, (peak-equity)/peak);

      trades.push({ pnl:adjPnl });
      pos=null;
    }
  }

  const wins = trades.filter(t=>t.pnl>0);
  const losses = trades.filter(t=>t.pnl<=0);
  const winrate = trades.length ? wins.length/trades.length : 0;
  const grossWin = wins.reduce((a,t)=>a+t.pnl,0);
  const grossLossAbs = Math.abs(losses.reduce((a,t)=>a+t.pnl,0));
  const pf = grossLossAbs ? grossWin/grossLossAbs : (grossWin>0 ? 999 : 0);
  const ret = (equity-1);

  return { trades, winrate, pf, dd, ret };
}

function backtestEnsemble(candles, ind, stratFns, cfg, minVotes){
  let pos=null;
  let equity=1, peak=1, dd=0;
  const trades=[];
  const risk = Number(cfg.risk);

  for(let i=2;i<candles.length;i++){
    const price=candles[i].close;
    const a=ind.atr[i] ?? 0;

    const sigs = stratFns.map(fn=>fn(i, ind, candles)).filter(Boolean);
    const votesBuy = sigs.filter(s=>s.enter==="BUY").length;
    const votesSell = sigs.filter(s=>s.enter==="SELL").length;
    const exitBuyVotes = sigs.filter(s=>s.exitBuy).length;
    const exitSellVotes = sigs.filter(s=>s.exitSell).length;

    if(!pos){
      if(votesBuy>=minVotes && votesBuy>votesSell){
        const { slDist, tpDist } = sltp(price, a, cfg.slMode, cfg.tpMode);
        pos={ side:"BUY", entry:price, sl:price-slDist, tp:price+tpDist };
      }else if(votesSell>=minVotes && votesSell>votesBuy){
        const { slDist, tpDist } = sltp(price, a, cfg.slMode, cfg.tpMode);
        pos={ side:"SELL", entry:price, sl:price+slDist, tp:price-tpDist };
      }
      continue;
    }

    const hi=candles[i].high, lo=candles[i].low;
    let exit=null;

    if(pos.side==="BUY"){
      if(lo<=pos.sl) exit=pos.sl;
      else if(hi>=pos.tp) exit=pos.tp;
      else if(votesSell>=minVotes || exitBuyVotes>=minVotes) exit=price;
    }else{
      if(hi>=pos.sl) exit=pos.sl;
      else if(lo<=pos.tp) exit=pos.tp;
      else if(votesBuy>=minVotes || exitSellVotes>=minVotes) exit=price;
    }

    if(exit!=null){
      const pnl = (pos.side==="BUY") ? (exit-pos.entry)/pos.entry : (pos.entry-exit)/pos.entry;
      const slPct = Math.abs((pos.sl - pos.entry)/pos.entry) || 0.001;
      const leverageLike = Math.min(5, risk / slPct);
      const adjPnl = pnl * leverageLike;

      equity *= (1 + adjPnl);
      peak = Math.max(peak, equity);
      dd = Math.max(dd, (peak-equity)/peak);

      trades.push({ pnl:adjPnl });
      pos=null;
    }
  }

  const wins = trades.filter(t=>t.pnl>0);
  const losses = trades.filter(t=>t.pnl<=0);
  const winrate = trades.length ? wins.length/trades.length : 0;
  const grossWin = wins.reduce((a,t)=>a+t.pnl,0);
  const grossLossAbs = Math.abs(losses.reduce((a,t)=>a+t.pnl,0));
  const pf = grossLossAbs ? grossWin/grossLossAbs : (grossWin>0 ? 999 : 0);
  const ret = (equity-1);

  return { trades, winrate, pf, dd, ret };
}

/* =========================
   UI render
   ========================= */
function rowHtml(sym, tf, strat, out){
  const win = out.winrate*100;
  const dd = out.dd*100;
  const ret = out.ret*100;
  const clsRet = ret>=0 ? "good" : "bad";
  return `
    <tr>
      <td><span class="tag">${escapeHtml(sym)}</span></td>
      <td class="mono">${escapeHtml(tf)}</td>
      <td>${escapeHtml(strat)}</td>
      <td class="small">${out.trades.length}</td>
      <td class="small">${fmt(win,2)}%</td>
      <td class="small">${fmt(out.pf,2)}</td>
      <td class="small">${fmt(dd,2)}%</td>
      <td class="small ${clsRet}">${fmt(ret,2)}%</td>
    </tr>
  `;
}
function activeStrategies(){
  const list=[];
  if($("#sEMA").checked) list.push({ name:"EMA+RSI", fn:(i,ind)=>stratEMA(i,ind) });
  if($("#sMACD").checked) list.push({ name:"MACD", fn:(i,ind)=>stratMACD(i,ind) });
  if($("#sBB").checked) list.push({ name:"Bollinger", fn:(i,ind)=>stratBB(i,ind) });
  if($("#sBR").checked) list.push({ name:"Breakout/PB", fn:(i,ind)=>stratBreakoutPullback(i,ind) });
  if($("#sC").checked) list.push({ name:"Candle", fn:(i,ind)=>stratCandles(i,ind) });
  return list;
}

/* =========================
   Run
   ========================= */
let stopFlag=false;
let lastExport=null;

async function run(){
  stopFlag=false;
  $("#btnRun").disabled=true;
  $("#btnStop").disabled=false;
  $("#btnExport").disabled=true;
  $("#tbl tbody").innerHTML="";
  $("#log").value="";
  $("#err").textContent="errores: 0";

  const limit=Math.max(200, Number($("#limit").value)||800);
  const risk=$("#risk").value;
  const slMode=$("#slMode").value;
  const tpMode=$("#tpMode").value;
  const votes=Math.max(2, Number($("#ensembleVotes").value)||2);

  const mode=$("#dataMode").value;
  const key=$("#twelveKey").value.trim();

  const tfs = selectedTFs();
  const symsRaw = $("#symbols").value.split("\n").map(s=>s.trim()).filter(Boolean);
  const strats = activeStrategies();

  $("#kSyms").textContent = symsRaw.length;
  $("#kTFs").textContent = tfs.length;
  $("#kStrats").textContent = strats.length;

  if(!symsRaw.length){ toast("Config","Agrega s√≠mbolos.","warn"); $("#btnRun").disabled=false; $("#btnStop").disabled=true; return; }
  if(!tfs.length){ toast("Config","Selecciona al menos 1 timeframe.","warn"); $("#btnRun").disabled=false; $("#btnStop").disabled=true; return; }
  if(!strats.length){ toast("Config","Activa al menos 1 estrategia.","warn"); $("#btnRun").disabled=false; $("#btnStop").disabled=true; return; }

  // Si hay no-cripto y modo permite TwelveData, exige key
  if(mode!=="binanceOnly"){
    const needKey = symsRaw.some(s=>!isCrypto(normalizeForexPair(s)));
    if(needKey && !key){
      toast("TwelveData","Falta API Key para divisas/XAU/√≠ndices.","bad");
      $("#btnRun").disabled=false; $("#btnStop").disabled=true;
      return;
    }
  }

  setStatus("resolviendo s√≠mbolos‚Ä¶", "rgba(255,204,102,.95)");
  log(`Resolviendo s√≠mbolos...`);
  const symsResolved = [];
  for(const s of symsRaw){
    if(stopFlag) break;
    const r = await resolveSymbol(s, mode, key);
    if(r?.resolved) symsResolved.push(r.resolved);
  }
  if(stopFlag){
    setStatus("detenido", "rgba(255,92,122,.95)");
    $("#btnRun").disabled=false; $("#btnStop").disabled=true;
    return;
  }
  log(`S√≠mbolos a procesar: ${symsResolved.join(", ")}`);

  setStatus("corriendo‚Ä¶", "rgba(255,204,102,.95)");
  log(`Iniciando backtest: TFs=${tfs.join(",")} velas=${limit} s√≠mbolos=${symsResolved.length} estrategias=${strats.length} ensembleVotes=${votes}`);

  const cfg={ risk, slMode, tpMode };
  const rows=[];
  let processed=0, errors=0;
  const totalWork = symsResolved.length * tfs.length;

  // Secuencial para evitar rate limits
  for(const tf of tfs){
    for(const sym of symsResolved){
      if(stopFlag) break;

      $("#prog").textContent = `${processed}/${totalWork}`;
      log(`Descargando ${sym} @ ${tf}‚Ä¶`);

      try{
        const candles = await fetchCandles(sym, tf, limit, mode, key);
        if(candles.length < 120) throw new Error(`Pocas velas (${candles.length}).`);

        const ind = computeIndicators(candles);

        // Individuales
        for(const st of strats){
          const out = backtestOne(candles, ind, (i,ind2)=>st.fn(i,ind2), cfg);
          rows.push({ sym, tf, strat: st.name, out });
        }

        // Ensemble
        const fns = strats.map(s=> (i,ind2)=>s.fn(i,ind2));
        const ens = backtestEnsemble(candles, ind, fns, cfg, votes);
        rows.push({ sym, tf, strat: `Ensemble(${votes}v)`, out: ens });

        processed++;
        $("#prog").textContent = `${processed}/${totalWork}`;

        // Anti rate-limit: TwelveData suele requerir pausas
        await sleep(isCrypto(sym) ? 220 : 520);
      }catch(e){
        errors++;
        $("#err").textContent = `errores: ${errors}`;
        log(`ERROR ${sym} @ ${tf}: ${e.message || e}`);
        toast("Error", `${sym} ${tf}: ${e.message || e}`, "bad");
        await sleep(650);
      }
    }
    if(stopFlag) break;
  }

  // Render
  rows.sort((a,b)=> (b.out.ret - a.out.ret));
  $("#tbl tbody").innerHTML = rows.map(r=>rowHtml(r.sym, r.tf, r.strat, r.out)).join("");

  // KPI agregado: ensemble promedio
  const ensRows = rows.filter(r=>String(r.strat).startsWith("Ensemble"));
  if(ensRows.length){
    const avgRet = ensRows.reduce((a,r)=>a+r.out.ret,0)/ensRows.length;
    const avgDD  = ensRows.reduce((a,r)=>a+r.out.dd,0)/ensRows.length;
    const cls = avgRet>=0 ? "good":"bad";
    $("#kEns").innerHTML = `<span class="${cls}">${fmt(avgRet*100,2)}%</span> / <span class="warn">${fmt(avgDD*100,2)}%</span>`;
  }else{
    $("#kEns").textContent="‚Äî";
  }

  lastExport = {
    createdAt: nowISO(),
    timeframes: tfs,
    limit, cfg, mode,
    symbols: symsResolved,
    strategies: strats.map(s=>s.name),
    votes,
    results: rows.map(r=>({
      symbol:r.sym, tf:r.tf, strategy:r.strat,
      trades:r.out.trades.length,
      winrate:r.out.winrate,
      pf:r.out.pf,
      dd:r.out.dd,
      ret:r.out.ret
    }))
  };
  $("#btnExport").disabled = !rows.length;

  if(stopFlag){
    setStatus("detenido", "rgba(255,92,122,.95)");
    toast("Backtest","Detenido por el usuario.","warn");
  }else{
    setStatus("completo", "rgba(25,211,162,.95)");
    toast("Backtest","Finalizado. Tabla ordenada por retorno (mejor arriba).","good");
  }

  $("#btnRun").disabled=false;
  $("#btnStop").disabled=true;
}

function exportJSON(){
  if(!lastExport) return;
  const content = JSON.stringify(lastExport, null, 2);
  const blob = new Blob([content], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download=`backtest_multiTF_${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  toast("Export","JSON descargado.","good");
}

/* =========================
   Wire
   ========================= */
renderTFGrid();
setStatus("listo", "rgba(169,183,229,.95)");
toast("Listo","Dale ‚ÄúResolver s√≠mbolos‚Äù (recomendado) y luego ‚ÄúCorrer Backtest‚Äù.","good");

$("#btnResolve").addEventListener("click", resolveAllSymbols);
$("#btnRun").addEventListener("click", run);
$("#btnStop").addEventListener("click", ()=>{
  stopFlag=true;
  setStatus("deteniendo‚Ä¶", "rgba(255,204,102,.95)");
});
$("#btnExport").addEventListener("click", exportJSON);

</script>

<!-- FIN -->
</body>
</html>
